#!/usr/bin/env python3


""" main executable for instl """

import sys
# force stdout to be utf-8. Sometimes it opens in ascii encoding
sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)
import os

import re
import tempfile
import appdirs
import datetime
import random
import string

from pyinstl.cmdOptions import CommandLineOptions, read_command_line_options
from utils import InstlException
import utils

# umask to 0 so that all files created under sudo, can be re-written under regular user.
os.umask(0)


current_os_names = utils.get_current_os_names()
os_family_name = current_os_names[0]
os_second_name = current_os_names[0]
if len(current_os_names) > 1:
    os_second_name = current_os_names[1]


def get_path_to_instl_app():
    """
    @return: returns the path to this
    """
    application_path = None
    if getattr(sys, 'frozen', False):
        application_path = os.path.realpath(sys.executable)
    elif __file__:
        application_path = os.path.realpath(__file__)
    return application_path


def get_instl_launch_command():
    """
    @return: returns the path to this
    """
    launch_command = None
    if getattr(sys, 'frozen', False):
        launch_command = utils.quoteme_double(os.path.realpath(sys.executable))
    elif __file__:
        if os_family_name == "Win":
            launch_command = " ".join((utils.quoteme_double(sys.executable), utils.quoteme_double(os.path.realpath(__file__))))
        else:
            launch_command = utils.quoteme_double(os.path.realpath(__file__))
    return launch_command


def get_data_folder():
    data_folder = None
    if getattr(sys, 'frozen', False):
        data_folder = getattr(sys, '_MEIPASS', None)
    elif __file__:
        data_folder = os.path.dirname(os.path.realpath(__file__))
    return data_folder


def main():
    """ Main instl entry point. Reads command line options and decides if to go into interactive or client mode.
    """
    options = CommandLineOptions()
    command_names = read_command_line_options(options, sys.argv[1:])
    initial_vars = {"__INSTL_EXE_PATH__": get_path_to_instl_app(),
                    "__CURR_WORKING_DIR__": os.getcwd(),  # the working directory when instl was launched
                    "__INSTL_LAUNCH_COMMAND__": get_instl_launch_command(),
                    "__INSTL_DATA_FOLDER__": get_data_folder(),
                    "__INSTL_COMPILED__": str(getattr(sys, 'frozen', False)),
                    "__PYTHON_VERSION__": sys.version_info,
                    "__COMMAND_NAMES__": command_names,
                    "__CURRENT_OS__": os_family_name,
                    "__CURRENT_OS_SECOND_NAME__": os_second_name,
                    "__CURRENT_OS_NAMES__": current_os_names,
                    "__SITE_DATA_DIR__": os.path.normpath(appdirs.site_data_dir()),
                    "__SITE_CONFIG_DIR__": os.path.normpath(appdirs.site_config_dir()),
                    "__USER_DATA_DIR__": os.path.normpath(appdirs.user_data_dir()),
                    "__USER_CONFIG_DIR__": os.path.normpath(appdirs.user_config_dir()),
                    "__USER_HOME_DIR__": os.path.normpath(os.path.expanduser("~")),
                    "__USER_DESKTOP_DIR__": os.path.normpath("$(__USER_HOME_DIR__)/Desktop"),
                    "__USER_TEMP_DIR__": os.path.normpath(os.path.join(tempfile.gettempdir(), "$(SYNC_BASE_URL_MAIN_ITEM)/$(REPO_NAME)")),
                    "__PATH_SEP__": os.path.sep,
                    "__INVOCATIONS_FILE_PATH__": utils.get_invocations_file_path()
                    }

    # remove newline characters that might lurk in the path (see tech support case 143589)
    adjusted_path = re.sub('[\r\n]', "?", utils.unicodify(os.environ.get("PATH", "PATH environment variable undefined")))
    initial_vars["__USER_PATH__"] = adjusted_path

    if os_family_name != "Win":
        initial_vars.update(
                    {"__USER_ID__": str(os.getuid()),
                     "__GROUP_ID__": str(os.getgid())})

    instance = None
    if options.command == "command-list":
        from pyinstl.instlCommandList import run_commands_from_file
        run_commands_from_file(initial_vars, options)
    elif options.mode == "client":
        from pyinstl.instlClient import InstlClientFactory
        instance = InstlClientFactory(initial_vars, options.command)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "doit":
        from pyinstl.instlDoIt import InstlDoIt
        instance = InstlDoIt(initial_vars)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "admin":
        if os_family_name not in ("Linux", "Mac"):
            raise EnvironmentError("instl admin commands can only run under Mac or Linux")
        from pyinstl.instlAdmin import InstlAdmin
        instance = InstlAdmin(initial_vars)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "interactive":
        from pyinstl.instlClient import InstlClient
        client = InstlClient(initial_vars)
        client.init_from_cmd_line_options(options)
        from pyinstl.instlAdmin import InstlAdmin
        from pyinstl.instlInstanceBase_interactive import go_interactive
        admin = InstlAdmin(initial_vars)
        admin.init_from_cmd_line_options(options)
        go_interactive(client, admin)
    elif options.mode == "do_something":
        from pyinstl.instlMisc import InstlMisc
        instance = InstlMisc(initial_vars, options.command)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "gui":
        if getattr(sys, 'frozen', False):
            print("gui command not available in compiled instl")
        else:
            from pyinstl.instlGui import InstlGui
            instance = InstlGui(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
    else:
        raise InstlException("incomprehensible command line options:\n", options)

    # make sure instance's dispose functions are called
    if instance is not None:
        del instance


class InvocationReporter(object):
    def __init__(self):
        self.invocations_file_path = None
        self.start_time = datetime.datetime.now()
        self.max_file_size = 400000
        self.random_invocation_name = ''.join(random.choice(string.ascii_lowercase) for i in range(16))

    def __enter__(self):
        try:
            self.invocations_file_path = utils.get_invocations_file_path()

            # if file too big rename it to ".1" - only one back copy is kept
            if os.path.isfile(self.invocations_file_path) and os.path.getsize(self.invocations_file_path) > self.max_file_size:
                backup_file_path = self.invocations_file_path + ".1"
                os.rename(self.invocations_file_path, backup_file_path)

            with utils.utf8_open(self.invocations_file_path, "a") as wfd:
                print("===", self.random_invocation_name, file=wfd, flush=True)
                print("start:", self.start_time, file=wfd, flush=True)
                print("instl:", sys.argv[0], file=wfd, flush=True)
                print("argv:", " ".join(sys.argv[1:]), file=wfd, flush=True)
        except:
            # this is a report so if something went wrong just forget it
            pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            with utils.utf8_open(self.invocations_file_path, "a") as wfd:
                end_time = datetime.datetime.now()
                if exc_val:
                    print("exception:", exc_val, file=wfd, flush=True)
                print("run time:", end_time-self.start_time, file=wfd, flush=True)
                print("end:", end_time, file=wfd, flush=True)
                print("===", self.random_invocation_name, file=wfd, flush=True)
        except:
            # this is a report so if something went wrong just forget it
            pass

if __name__ == "__main__":
    with InvocationReporter():
        main()
