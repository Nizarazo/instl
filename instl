#!/usr/bin/env python3


""" main executable for instl """

import sys
# force stdout to be utf-8. Sometimes it opens in ascii encoding
sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)
import os
#if os.environ.get("PYTHONIOENCODING", "not found").lower() not in ("utf8", "utf-8"):
#    print("PYTHONIOENCODING:", os.environ.get("PYTHONIOENCODING", "not found"))

import re
import tempfile
import appdirs
import datetime

from pyinstl.cmdOptions import CommandLineOptions, read_command_line_options
from utils import InstlException
import utils

# umask to 0 so that all files created under sudo, can be re-written under regular user.
os.umask(0)


current_os_names = utils.get_current_os_names()
os_family_name = current_os_names[0]
os_second_name = current_os_names[0]
if len(current_os_names) > 1:
    os_second_name = current_os_names[1]


def get_path_to_instl_app():
    """
    @return: returns the path to this
    """
    application_path = None
    if getattr(sys, 'frozen', False):
        application_path = os.path.realpath(sys.executable)
    elif __file__:
        application_path = os.path.realpath(__file__)
    return application_path


def get_instl_launch_command():
    """
    @return: returns the path to this
    """
    launch_command = None
    if getattr(sys, 'frozen', False):
        launch_command = utils.quoteme_double(os.path.realpath(sys.executable))
    elif __file__:
        if os_family_name == "Win":
            launch_command = " ".join((utils.quoteme_double(sys.executable), utils.quoteme_double(os.path.realpath(__file__))))
        else:
            launch_command = utils.quoteme_double(os.path.realpath(__file__))
    return launch_command


def get_data_folder():
    data_folder = None
    if getattr(sys, 'frozen', False):
        data_folder = getattr(sys, '_MEIPASS', None)
    elif __file__:
        data_folder = os.path.dirname(os.path.realpath(__file__))
    return data_folder


def main():
    """ Main instl entry point. Reads command line options and decides if to go into interactive or client mode.
    """
    options = CommandLineOptions()
    command_names = read_command_line_options(options, sys.argv[1:])
    initial_vars = {"__INSTL_EXE_PATH__": get_path_to_instl_app(),
                    "__CURR_WORKING_DIR__": os.getcwd(),  # the working directory when instl was launched
                    "__INSTL_LAUNCH_COMMAND__": get_instl_launch_command(),
                    "__INSTL_DATA_FOLDER__": get_data_folder(),
                    "__INSTL_COMPILED__": str(getattr(sys, 'frozen', False)),
                    "__PYTHON_VERSION__": sys.version_info,
                    "__COMMAND_NAMES__": command_names,
                    "__CURRENT_OS__": os_family_name,
                    "__CURRENT_OS_SECOND_NAME__": os_second_name,
                    "__CURRENT_OS_NAMES__": current_os_names,
                    "__SITE_DATA_DIR__": os.path.normpath(appdirs.site_data_dir()),
                    "__SITE_CONFIG_DIR__": os.path.normpath(appdirs.site_config_dir()),
                    "__USER_DATA_DIR__": os.path.normpath(appdirs.user_data_dir()),
                    "__USER_CONFIG_DIR__": os.path.normpath(appdirs.user_config_dir()),
                    "__USER_HOME_DIR__": os.path.normpath(os.path.expanduser("~")),
                    "__USER_DESKTOP_DIR__": os.path.normpath("$(__USER_HOME_DIR__)/Desktop"),
                    "__USER_TEMP_DIR__": os.path.normpath(os.path.join(tempfile.gettempdir(), "$(SYNC_BASE_URL_MAIN_ITEM)/$(REPO_NAME)")),
                    "__PATH_SEP__": os.path.sep
                    }

    # remove newline characters that might lurk in the path (see tech support case 143589)
    adjusted_path = re.sub('[\r\n]', "?", utils.unicodify(os.environ.get("PATH", "PATH environment variable undefined")))
    initial_vars["__USER_PATH__"] = adjusted_path

    if os_family_name != "Win":
        initial_vars.update(
                    {"__USER_ID__": str(os.getuid()),
                     "__GROUP_ID__": str(os.getgid())})

    if options.command == "command-list":
        from pyinstl.instlCommandList import run_commands_from_file
        run_commands_from_file(initial_vars, options)
    elif options.mode == "client":
        from pyinstl.instlClient import InstlClientFactory
        instance = InstlClientFactory(initial_vars, options.command)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "doit":
        from pyinstl.instlDoIt import InstlDoIt
        instance = InstlDoIt(initial_vars)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "admin":
        if os_family_name not in ("Linux", "Mac"):
            raise EnvironmentError("instl admin commands can only run under Mac or Linux")
        from pyinstl.instlAdmin import InstlAdmin
        instance = InstlAdmin(initial_vars)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "interactive":
        from pyinstl.instlClient import InstlClient
        client = InstlClient(initial_vars)
        client.init_from_cmd_line_options(options)
        from pyinstl.instlAdmin import InstlAdmin
        from pyinstl.instlInstanceBase_interactive import go_interactive
        admin = InstlAdmin(initial_vars)
        admin.init_from_cmd_line_options(options)
        go_interactive(client, admin)
    elif options.mode == "do_something":
        from pyinstl.instlMisc import InstlMisc
        instance = InstlMisc(initial_vars)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "gui":
        if getattr(sys, 'frozen', False):
            print("gui command not available in compiled instl")
        else:
            from pyinstl.instlGui import InstlGui
            instance = InstlGui(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
    else:
        raise InstlException("incomprehensible command line options:\n", options)


class InvocationReporter(object):
    def __init__(self):
        self.wfd = None
        self.start_time = datetime.datetime.now()

    def __enter__(self):
        try:

            user_folder = os.path.expanduser("~")
            # create the invocations file if the user has instl_config.yaml
            if os.path.isfile(os.path.join(user_folder, "instl_config.yaml")):
                invocations_file_path = os.path.join(user_folder, "instl_invocations.txt")
                self.wfd = utils.utf8_open(invocations_file_path, "a")
                print(self.start_time, file=self.wfd)
                print("argv:", sys.argv, file=self.wfd)
                self.wfd.flush()
        except:
            # this is just a report so if something went wrong just forget it
            pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.wfd:
            self.end_time = datetime.datetime.now()
            print("run time:", self.end_time-self.start_time, file=self.wfd)
            print(self.end_time, file=self.wfd)
            print("===", file=self.wfd)
            self.wfd.close()

if __name__ == "__main__":
    with InvocationReporter():
        main()
