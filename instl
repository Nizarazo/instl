#!/usr/bin/env python3.6


""" main executable for instl """

import sys
# force stdout to be utf-8. Sometimes it opens in ascii encoding
sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)
import os
import re
import json
import inspect
import logging
from logging.config import dictConfig
import tempfile
import appdirs
import datetime
import random
import string
import sqlite3

from pyinstl.cmdOptions import CommandLineOptions, read_command_line_options
from utils import InstlException
import utils

log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)

# umask to 0 so that all files created under sudo, can be re-written under regular user.
os.umask(0)


current_os_names = utils.get_current_os_names()
os_family_name = current_os_names[0]
os_second_name = current_os_names[0]
if len(current_os_names) > 1:
    os_second_name = current_os_names[1]


def get_path_to_instl_app():
    """
    @return: returns the path to this
    """
    application_path = None
    if getattr(sys, 'frozen', False):
        application_path = os.path.realpath(sys.executable)
    elif __file__:
        application_path = os.path.realpath(__file__)
    return application_path


def get_instl_launch_command():
    """
    @return: returns the path to this
    """
    launch_command = None
    if getattr(sys, 'frozen', False):
        launch_command = utils.quoteme_double(os.path.realpath(sys.executable))
    elif __file__:
        if os_family_name == "Win":
            launch_command = " ".join((utils.quoteme_double(sys.executable), utils.quoteme_double(os.path.realpath(__file__))))
        else:
            launch_command = utils.quoteme_double(os.path.realpath(__file__))
    return launch_command


def get_data_folder():
    data_folder = None
    if getattr(sys, 'frozen', False):
        data_folder = getattr(sys, '_MEIPASS', None)
    elif __file__:
        data_folder = os.path.dirname(os.path.realpath(__file__))
    return data_folder


def config_logger():
    system_log_file_path = utils.get_system_log_file_path()
    d = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'simple': {
                'class': 'logging.Formatter',
                'format': '%(message)s'
            },
            'detailed': {
                'class': 'logging.Formatter',
                'datefmt': '%Y-%m-%d_%H:%M:%S',
                'format': '%(asctime)s.%(msecs)03d | %(levelname)-7s|%(stack_lvl)s %(message)-150s| {%(parent_mod)s.%(parent_func_name)s|%(parent_line_no)s} | {%(name)s.%(funcName)s|%(lineno)-3s}'
            },
            'json': {
                '()': JsonFormatter,
                'format': '%(message)s'
            }
        },
        'filters': {
            'parent': {
                '()': ParentFilter,
            }
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'level': 'INFO',
                'formatter': 'simple',
                'stream': sys.stdout
            },
            'errors': {
                'class': 'logging.StreamHandler',
                'level': 'ERROR',
                'formatter': 'simple',
                'stream': sys.stderr
            },
            'system_log': {
                'class': 'logging.handlers.RotatingFileHandler',
                'level': 'DEBUG',
                'formatter': 'detailed',
                'filename': system_log_file_path,
                'mode': 'a',
                'maxBytes': 5000000,
                'backupCount': 10,
                'filters': ['parent']
            }
        },
        'root': {
            'level': 'DEBUG',  # Currently disabled. Need to add verbose mode from cmd line
            'handlers': ['console', 'errors', 'system_log'],
        },
    }
    os.makedirs(os.path.dirname(system_log_file_path), exist_ok=True)
    dictConfig(d)


class ParentFilter(logging.Filter):
    '''Adds additional info to the log message - stack level, parent info: module, function name, line number.'''
    def filter(self, record):
        record.name = re.sub('.*\.', '', record.name)
        try:
            stack = inspect.stack()
            record.stack_lvl = '  ' * (len(stack) - 9)
            record.parent_mod = inspect.getmodulename(stack[8][1])
            record.parent_func_name = stack[8][3]
            record.parent_line_no = stack[8][2]
        except IndexError:
            record.stack_lvl = ''
            record.parent_mod = ''
            record.parent_func_name = ''
            record.parent_line_no = ''
        return True


class JsonFormatter(object):
    ATTR_TO_JSON = ['created', 'filename', 'funcName', 'levelname', 'lineno', 'module', 'msecs', 'msg', 'name', 'pathname', 'process', 'processName', 'relativeCreated', 'thread', 'threadName']

    def __init__(self, **kwargs):
        super().__init__()

    def format(self, record):
        obj = {attr: getattr(record, attr)
               for attr in self.ATTR_TO_JSON}
        return json.dumps(obj, indent=4)


def main():
    """ Main instl entry point. Reads command line options and decides if to go into interactive or client mode.
    """
    options = CommandLineOptions()
    command_names = read_command_line_options(options, sys.argv[1:])
    initial_vars = {"__INSTL_EXE_PATH__": get_path_to_instl_app(),
                    "__CURR_WORKING_DIR__": os.getcwd(),  # the working directory when instl was launched
                    "__INSTL_LAUNCH_COMMAND__": get_instl_launch_command(),
                    "__INSTL_DATA_FOLDER__": get_data_folder(),
                    "__INSTL_DEFAULTS_FOLDER__": "$(__INSTL_DATA_FOLDER__)/defaults",
                    "__INSTL_COMPILED__": str(getattr(sys, 'frozen', False)),
                    "__PYTHON_VERSION__": sys.version_info,
                    "__PYSQLITE3_VERSION__": sqlite3.version,
                    "__SQLITE_VERSION__": sqlite3.sqlite_version,
                    "__COMMAND_NAMES__": command_names,
                    "__CURRENT_OS__": os_family_name,
                    "__CURRENT_OS_SECOND_NAME__": os_second_name,
                    "__CURRENT_OS_NAMES__": current_os_names,
                    "__SITE_DATA_DIR__": os.path.normpath(appdirs.site_data_dir()),
                    "__SITE_CONFIG_DIR__": os.path.normpath(appdirs.site_config_dir()),
                    "__USER_DATA_DIR__": os.path.normpath(appdirs.user_data_dir()),
                    "__USER_CONFIG_DIR__": os.path.normpath(appdirs.user_config_dir()),
                    "__USER_HOME_DIR__": os.path.normpath(os.path.expanduser("~")),
                    "__USER_DESKTOP_DIR__": os.path.normpath("$(__USER_HOME_DIR__)/Desktop"),
                    "__USER_TEMP_DIR__": os.path.normpath(os.path.join(tempfile.gettempdir(), "$(SYNC_BASE_URL_MAIN_ITEM)/$(REPO_NAME)")),
                    "__SYSTEM_LOG_FILE_PATH__": utils.get_system_log_file_path(),
                    "__INVOCATION_RANDOM_ID__": ''.join(random.choice(string.ascii_lowercase) for _ in range(16)),
                    "__SUDO_USER__": os.environ.get("SUDO_USER", "no set")
                    }

    if os_family_name != "Win":
        initial_vars.update(
                    {"__USER_ID__": str(os.getuid()),
                     "__GROUP_ID__": str(os.getgid())})
    else:
        initial_vars.update(
                    {"__USER_ID__": -1,
                     "__GROUP_ID__": -1})

    # config_logger()
    instance = None
    if options.__MAIN_COMMAND__ == "command-list":
        from pyinstl.instlCommandList import run_commands_from_file
        run_commands_from_file(initial_vars, options)
    elif options.mode == "client":
        from pyinstl.instlClient import InstlClientFactory
        instance = InstlClientFactory(initial_vars, options.__MAIN_COMMAND__)
        instance.progress("welcome to instl", instance.get_version_str(short=True), options.__MAIN_COMMAND__)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "doit":
        from pyinstl.instlDoIt import InstlDoIt
        instance = InstlDoIt(initial_vars)
        instance.progress("welcome to instl", instance.get_version_str(short=True), options.__MAIN_COMMAND__)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "admin":
        if os_family_name not in ("Linux", "Mac"):
            raise EnvironmentError("instl admin commands can only run under Mac or Linux")
        from pyinstl.instlAdmin import InstlAdmin
        instance = InstlAdmin(initial_vars)
        instance.progress("welcome to instl", instance.get_version_str(short=True), options.__MAIN_COMMAND__)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "interactive":
        from pyinstl.instlClient import InstlClient
        client = InstlClient(initial_vars)
        client.init_from_cmd_line_options(options)
        from pyinstl.instlAdmin import InstlAdmin
        from pyinstl.instlInstanceBase_interactive import go_interactive
        admin = InstlAdmin(initial_vars)
        admin.init_from_cmd_line_options(options)
        go_interactive(client, admin)
    elif options.mode == "do_something":
        from pyinstl.instlMisc import InstlMisc
        instance = InstlMisc(initial_vars, options.__MAIN_COMMAND__)
        instance.progress("welcome to instl", instance.get_version_str(short=True), options.__MAIN_COMMAND__)
        instance.init_from_cmd_line_options(options)
        instance.do_command()
    elif options.mode == "gui":
        if getattr(sys, 'frozen', False):
            print("gui command not available in compiled instl")
        else:
            from pyinstl.instlGui import InstlGui
            instance = InstlGui(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
    else:
        raise InstlException("incomprehensible command line options:\n", options)

    # make sure instance's dispose functions are called
    if instance is not None:
        instance.close()


class InvocationReporter(object):
    def __init__(self) -> None:
        self.start_time = datetime.datetime.now()
        self.random_invocation_name = ''.join(random.choice(string.ascii_lowercase) for i in range(16))

    def __enter__(self):
        try:
            config_logger()
            log.debug(f"===== {self.random_invocation_name} =====")
            log.debug(f"Start: {self.start_time}")
            log.debug(f"instl: {sys.argv[0]}")
            log.debug(f'argv: {" ".join(sys.argv[1:])}')
        except Exception as e:
            log.warning(f'instl log file report start failed - {e}')

    def __exit__(self, exc_type, exc_val, exc_tb):
        try:
            end_time = datetime.datetime.now()
            if exc_val:
                log.exception(exc_val)
            log.debug(f"Run time: {end_time-self.start_time}")
            log.debug(f"End: {end_time}")
            log.debug(f"===== {self.random_invocation_name} =====")
        except Exception as e:
            log.warning(f'instl log file report finalize failed - {e}')


if __name__ == "__main__":
    with InvocationReporter():
        main()
