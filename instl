#!/usr/bin/env python2.7

""" main executable for instl """

from __future__ import print_function


import sys
import os
import argparse

# setup logging, must be done before other imports
from pyinstl.log_utils import setup_logging
setup_logging("instl", "instl")
from pyinstl.log_utils import func_log_wrapper
from pyinstl.utils import get_current_os_names

import pyinstl
from pyinstl.instlException import InstlFatalException, InstlException

current_os_names = get_current_os_names()
os_family_name = current_os_names[0]
os_second_name = current_os_names[0]
if len(current_os_names) > 1:
    os_second_name = current_os_names[1]

def get_path_to_instl_app():
    """
    @return: returns the path to this
    """
    application_path = None
    if getattr(sys, 'frozen', False):
        application_path = os.path.realpath(sys.executable)
    elif __file__:
        application_path = os.path.realpath(__file__)
    return application_path

class CommandLineOptions(object):
    """ namespace object to give to parse_args
        holds command line options
    """
    def __init__(self):
        self.command = None
        self.input_file = None
        self.output_file = None
        self.run = False
        self.state_file = None
        self.todo_args = None
        self.props_file = None
        self.filter_out = None
        self.filter_in = None
        self.repo_rev = None
        self.config_file = None
        self.folder = None

    def __str__(self):
        return "\n".join([''.join((n, ": ", str(v))) for n, v in sorted(vars(self).iteritems())])

def prepare_args_parser():
    """
    Prepare the parsers for command line arguments
    """
    def decent_convert_arg_line_to_args(self, arg_line):
        """ parse a file with options so that we do not have to write one sub-option
            per line.  Remove empty lines, comment lines, and end of line comments.
            ToDo: handle quotes
        """
        line_no_whitespace = arg_line.strip()
        if line_no_whitespace and line_no_whitespace[0] != '#':
            for arg in line_no_whitespace.split():
                if not arg:
                    continue
                elif  arg[0] == '#':
                    break
                yield arg

    parser = argparse.ArgumentParser(description='instl: cross platform svn based installer',
                    prefix_chars='-+',
                    fromfile_prefix_chars='@',
                    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    argparse.ArgumentParser.convert_arg_line_to_args = decent_convert_arg_line_to_args

    subparsers = parser.add_subparsers(dest='command', help='sub-command help')
    parser_sync = subparsers.add_parser('sync',
                                        help='sync files to be installed from server to temp folder')
    parser_copy = subparsers.add_parser('copy',
                                        help='copy files from temp folder to target paths')
    parser_synccopy = subparsers.add_parser('synccopy',
                                        help='sync files to be installed from server to temp \
                                        folder and copy files from temp folder to target paths')
    parser_trans = subparsers.add_parser('trans',
                                        help='translate svn map files from one format to another')
    parser_createlinks = subparsers.add_parser('createlinks',
                                        help='create links from the base SVN checkout folder for a specific version')
    parser_up2S3 = subparsers.add_parser('up2s3',
                                        help='upload installation sources to S3')
    parser_up_repo_rev = subparsers.add_parser('up_repo_rev',
                                        help='upload repository revision file to admin folder')
    parser_fix_props = subparsers.add_parser('fix_props',
                                        help='create svn commands to remove executable bit from files that should not be marked executable')

    # add --out to parsers that need it
    for subparser in (parser_sync, parser_copy, parser_synccopy, parser_trans, parser_createlinks, parser_up2S3, parser_fix_props):
        standard_options = subparser.add_argument_group(description='standard arguments:')
        standard_options.add_argument('--out', '-o',
                                    required=True,
                                    nargs=1,
                                    metavar='path-to-output-file',
                                    dest='output_file',
                                    help="out put file")


    for subparser in (parser_sync, parser_copy, parser_synccopy):
        subparser.set_defaults(mode='client')
        standard_options = subparser.add_argument_group(description='standard arguments:')
        standard_options.add_argument('--in', '-i',
                                    required=True,
                                    nargs='+',
                                    metavar='path-to-input-file',
                                    dest='input_file',
                                    help="file to read index and definitions from")
        standard_options.add_argument('--run', '-r',
                                    required=False,
                                    default=False,
                                    action='store_true',
                                    dest='run',
                                    help="run the installation instructions script")
        standard_options.add_argument('--state', '-s',
                                    required=False,
                                    nargs='?',
                                    const="stdout",
                                    metavar='path-to-state-file',
                                    dest='state_file',
                                    help="a file to write program state - good for debugging")

    for subparser in (parser_trans, ):
        subparser.set_defaults(mode='admin')
        trans_options = subparser.add_argument_group(description='translate arguments:')
        trans_options.add_argument('--in', '-i',
                                    required=True,
                                    nargs=1,
                                    metavar='list-of-input-file',
                                    dest='input_file',
                                    help="file to read svn information from")
        trans_options.add_argument('--props', '-p',
                                    required=False,
                                    nargs=1,
                                    metavar='path-to-props-file',
                                    dest='props_file',
                                    help="file to read svn properties from")
        trans_options.add_argument('--filter-out',
                                    required=False,
                                    nargs='+',
                                    metavar='paths-to-filter-out',
                                    dest='filter_out',
                                    help="paths to filter out, comma separated")
        trans_options.add_argument('--filter-in',
                                    required=False,
                                    nargs=1,
                                    metavar='version-to-filter-in',
                                    dest='filter_in',
                                    help="version to filter in, all other version will be left out")
        trans_options.add_argument('--config_file', '-s',
                                    required=False,
                                    nargs=1,
                                    metavar='path-to-config-file',
                                    dest='config_file',
                                    help="path to config-file")

    for subparser in (parser_createlinks, ):
        subparser.set_defaults(mode='admin')
        createlinks_options = subparser.add_argument_group(description='admin arguments:')
        createlinks_options.add_argument('--config_file', '-s',
                                    required=True,
                                    nargs=1,
                                    metavar='path-to-config-file',
                                    dest='config_file',
                                    help="path to config-file")
        createlinks_options.add_argument('--run',
                                    required=False,
                                    default=False,
                                    action='store_true',
                                    dest='run',
                                    help="run the installation instructions script")

    for subparser in (parser_up2S3, ):
        subparser.set_defaults(mode='admin')
        up2S3_options = subparser.add_argument_group(description='s3 arguments:')
        up2S3_options.add_argument('--config_file', '-s',
                                    required=True,
                                    nargs=1,
                                    metavar='path-to-config-file',
                                    dest='config_file',
                                    help="path to config-file")
        up2S3_options.add_argument('--run',
                                    required=False,
                                    default=False,
                                    action='store_true',
                                    dest='run',
                                    help="run the installation instructions script")

    for subparser in (parser_up_repo_rev, ):
        subparser.set_defaults(mode='admin')
        parser_up_repo_rev_options = subparser.add_argument_group(description='up repo rev arguments:')
        parser_up_repo_rev_options.add_argument('--in', '-i',
                                    required=True,
                                    nargs=1,
                                    metavar='list-of-input-file',
                                    dest='input_file',
                                    help="file to up load as repo rev")
        parser_up_repo_rev_options.add_argument('--config_file', '-s',
                                    required=True,
                                    nargs=1,
                                    metavar='path-to-config-file',
                                    dest='config_file',
                                    help="path to config-file")
    for subparser in (parser_fix_props, ):
        subparser.set_defaults(mode='admin')
        parser_fix_props_options = subparser.add_argument_group(description='fix executable bit options:')
        parser_fix_props_options.add_argument('--folder', '-f',
                                    required=True,
                                    nargs=1,
                                    metavar='svn-folder-to-check',
                                    dest='folder',
                                    help="svn folder to check for exec bit")

    parser_version = subparsers.add_parser('version', help='display instl version')
    parser_version.set_defaults(mode='do_something')


    if 'Win' not in current_os_names:
        parser_create_readlinks = subparsers.add_parser('create_readlinks',
                                            help='replace symlinks with .readlink files')
        parser_create_readlinks.set_defaults(mode='do_something')
        symlink_options = parser_create_readlinks.add_argument_group(description='create_readlinks arguments:')
        symlink_options.add_argument('--in', '-i',
                                required=True,
                                nargs=1,
                                metavar='folder-to-replace-symlinks-in',
                                dest='input_file',
                                help="folder to replace symlinks in")

        parser_resolve_readlinks = subparsers.add_parser('resolve_readlinks',
                                            help='replace .readlink files with symlinks')
        parser_resolve_readlinks.set_defaults(mode='do_something')
        symlink_options = parser_resolve_readlinks.add_argument_group(description='resolve_readlinks arguments:')
        symlink_options.add_argument('--in', '-i',
                                required=True,
                                nargs=1,
                                metavar='folder-to-resolve-readlinks-in',
                                dest='input_file',
                                help="folder to resolve readlinks in")

    if 'Mac' in current_os_names:
        parser_alias = subparsers.add_parser('alias',
                                            help='create Mac OS alias')
        parser_alias.set_defaults(mode='do_something')
        parser_alias.add_argument('todo_args',
                                action='append',
                                metavar='path_to_original',
                                help="paths to original file")
        parser_alias.add_argument('todo_args',
                                action='append',
                                metavar='path_to_alias',
                                help="paths to original file and to alias file")
    return parser

@func_log_wrapper
def read_command_line_options(name_space_obj, arglist=None):
    """ parse command line options """
    #args_str = "No options given"
    # todo: restore __COMMAND_LINE_OPTIONS__
    #if arglist is not None:
    #    logging.info("arglist: %s", " ".join(arglist))
    #self.cvl.add_const_config_variable('__COMMAND_LINE_OPTIONS__', "read only value", args_str)
    if not arglist or len(arglist) == 0:
        pass
        # No command line options given, but there maybe a "auto run" file with options
        #auto_run_file_path = None
        # todo: restore autorun file reading
        #auto_run_file_name = "auto_run_instl.yaml"
        #auto_run_file_path = self.search_paths_helper.find_file_with_search_paths(auto_run_file_name)
        #if auto_run_file_path:
        #    arglist = ("@"+auto_run_file_path,)
        #    logging.info("found auto run file %s", auto_run_file_name)

    if arglist and len(arglist) > 0:
        # Command line options were given or auto run file was found
        parser = prepare_args_parser()
        parser.parse_args(arglist, namespace=name_space_obj)
    else:
        # No command line options were given
        name_space_obj.mode = "interactive"

@pyinstl.log_utils.func_log_wrapper
def main():
    """ Main instl entry point. Reads command line options and decides if to go into interactive or client mode.
    """
    try:
        sys.stderr = sys.stdout
        initial_vars = {"__INSTL_EXE_PATH__": get_path_to_instl_app()}
        options = CommandLineOptions()
        read_command_line_options(options, sys.argv[1:])
        if options.mode == "client":
            from pyinstl.instlClient import InstlClient
            instance = InstlClient(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
        elif options.mode == "admin":
            from pyinstl.instlAdmin import InstlAdmin
            instance = InstlAdmin(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
        elif options.mode == "interactive":
            from pyinstl.instlClient import InstlClient
            client = InstlClient(initial_vars)
            client.init_from_cmd_line_options(options)
            from pyinstl.instlAdmin import InstlAdmin
            from pyinstl.instlInstanceBase_interactive import go_interactive
            admin = InstlAdmin(initial_vars)
            admin.init_from_cmd_line_options(options)
            go_interactive(client, admin)
        elif options.mode == "do_something":
            from pyinstl.instlMisc import InstlMisc
            instance = InstlMisc(initial_vars)
            instance.init_from_cmd_line_options(options)
            instance.do_command()
        else:
            raise InstlException("incomprehensible command line options:\n", options)
    except InstlException as instl_except:
        print("instl exception", instl_except.message)
        # from pyinstl.log_utils import debug_logging_started
        #from pyinstl.log_utils import get_log_file_path
        #print(get_log_file_path('instl', 'instl', True))
        # if debug_logging_started:
        #     import traceback
            # traceback.print_exception(type(instl_except.original_exception),
            #                           instl_except.original_exception,
            #                           sys.exc_info()[2])
        raise
    except InstlFatalException as instlEx:
        # print(instlEx)
        raise
    except Exception:
        print("unhandled exception")
        # import traceback
        # traceback.print_exc()
        raise

if __name__ == "__main__":
    main()
